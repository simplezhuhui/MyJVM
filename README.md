#jvm学习总结
1. jvm入门级相关概念：
     1.1 java从编码到执行的过程：java文件经过javac编译生成class字节码文件。
      -编译器补充知识： 
         --前端编译器：把.java转变为.class的过程。如Sun的Javac、IDE工具中的编译器。
         --JIT编译器：把字节码转变为机器码的过程，如HotSpot VM的C1、C2编译器。 
         --AOT编译器：静态提前编译器，直接将*.java文件编译本地机器代码的过程。
     1.2 字节码文件执行java命令，被类加载器加载到内存中（同时加载的还有一些java类库），然后会调用字节码
         解释器或者JIT即时编译器，进行解释或编译，最后交给执行引擎执行（面对操作系统和硬件）。
     1.3 JVM是一种规范，和任何语言无关，只和class文件有关，只有特定格式的class文件才能被jvm识别和执行。
     1.4 有多种jvm的实现，Hotspot/Jrokit/J9-IBM/Microsoft VM/TaoBao VM/azul zing...
2. class文件格式
     2.1 class文件就是一个二进制字节流,由虚拟机解释。
     2.2 数据类型有u1/u2/u4/u8/_info
     2.3 一些工具查看二进制、十六进制文件：BinEd、JClassLib..
     2.4 具体内容结构(按顺序从前往后)：
        --u4:魔数 CAFE BABE 代表文件类型的标识。
        --u4:版本号：minor+major
        --u2:常量池中常量个数：0010  常量从#1开始，#0是预留的一个常量编号。 
        --长度为常量个数-1的表，存储各种常量
        .....
3. class文件加载过程：
     3.1 加载：通过类加载器，将class文件加载到JVM中（内存）,并且生成一个Class对象，该对象指向二进制文件。
     3.2 链接：
       3.2.1 验证：class文件格式是否符合jvm规范
       3.2.2 准备：创建类或接口中的静态变量，并且给它们赋初始值，
       3.2.3 解析：将常量池中的符号应用，替换为直接引用，或者叫可以直接访问的内存地址。
     3.3 初始化：真正去执行类的初始化代码逻辑，包括静态变量的赋值，以及静态代码块中的逻辑。
  
4. 双亲委派模型：
     4.1 简单定义：当类加载器试图去加载某个类型的时候，除非父加载器找不到相应类型，否则尽量将加载任务
                   代理给当前加载器的父加载器去加载。
     4.2：使用原因：主要是为了安全，防止恶意的加载，另外避免类的重复加载，浪费资源。
5. 类加载器分类：
    1.BootStrap Class-Loader: 启动类加载器，加载jre/lib文件夹下的jar包，String等。
    2.Extension Class-Loader：扩展类加载器，加载jre/lib/ext/文件夹下的jar包。
    3.App Class-Loader：应用类加载器（系统类加载器）：加载classpath里面的内容，我们自己写的类。
    4.自定义加载器:
6. 几个API方法：
    6.1：getClassLoader():获得调用该方法的类的加载器，也就是被哪个类加载进虚拟机的。
    6.2：getParent():获得调用该方法的加载器的父加载器。
    注意: *父加载器并不是继承关系，是在当前加载器内有一个ClassLoader类型的变量，叫parent,指向父加载器。
          *也不是加载当前加载器的加载器（加载器本身也是一个类，需要被加载）,ext/app加载器都是被启动类加载器加载的，调用getClassLoader返回null.
       
7.Launcher 
     bootstrap/ext/app 这些加载器都是Launcher的静态内部类，在Launcher内定义了各自的访问范围。 

8.自定义类加载器
    8.1 调用加载器的loadClass()方法，会返回Class对象。

    