#jvm学习总结
##1. jvm入门级相关概念：
     1.1 java从编码到执行的过程：java文件经过javac编译生成class字节码文件。
      -编译器补充知识： 
         --前端编译器：把.java转变为.class的过程。如Sun的Javac、IDE工具中的编译器。
         --JIT编译器：把字节码转变为机器码的过程，如HotSpot VM的C1、C2编译器。 
         --AOT编译器：静态提前编译器，直接将*.java文件编译本地机器代码的过程。
     1.2 字节码文件执行java命令，被类加载器加载到内存中（同时加载的还有一些java类库），然后会调用字节码
         解释器或者JIT即时编译器，进行解释或编译，最后交给执行引擎执行（面对操作系统和硬件）。
     1.3 JVM是一种规范，和任何语言无关，只和class文件有关，只有特定格式的class文件才能被jvm识别和执行。
     1.4 有多种jvm的实现，Hotspot/Jrokit/J9-IBM/Microsoft VM/TaoBao VM/azul zing...
##2. class文件格式
     2.1 class文件就是一个二进制字节流,由虚拟机解释。
     2.2 数据类型有u1/u2/u4/u8/_info
     2.3 一些工具查看二进制、十六进制文件：BinEd、JClassLib..
     2.4 具体内容结构(按顺序从前往后)：
        --u4:魔数 CAFE BABE 代表文件类型的标识。
        --u4:版本号：minor+major
        --u2:常量池中常量个数：0010  常量从#1开始，#0是预留的一个常量编号。 
        --长度为常量个数-1的表，存储各种常量
        .....
##3. class文件加载过程：
     3.1 加载：通过类加载器，将class文件加载到JVM中（内存）,并且生成一个Class对象，该对象指向二进制文件。
     3.2 链接：
       3.2.1 验证：class文件格式是否符合jvm规范
       3.2.2 准备：创建类或接口中的静态变量，并且给它们赋初始值，
       3.2.3 解析：将常量池中的符号应用，替换为直接引用，或者叫可以直接访问的内存地址。
     3.3 初始化：真正去执行类的初始化代码逻辑，包括静态变量的赋值，以及静态代码块中的逻辑。
  
##4. 双亲委派模型：
     4.1 简单定义：当类加载器试图去加载某个类型的时候，除非父加载器找不到相应类型，否则尽量将加载任务
                   代理给当前加载器的父加载器去加载。
     4.2：使用原因：主要是为了安全，防止恶意的加载，另外避免类的重复加载，浪费资源。
##5. 类加载器分类：
    1.BootStrap Class-Loader: 启动类加载器，加载jre/lib文件夹下的jar包，String等。
    2.Extension Class-Loader：扩展类加载器，加载jre/lib/ext/文件夹下的jar包。
    3.App Class-Loader：应用类加载器（系统类加载器）：加载classpath里面的内容，我们自己写的类。
    4.自定义加载器:
##6. 几个API方法：
    6.1：getClassLoader():获得调用该方法的类的加载器，也就是被哪个类加载进虚拟机的。
    6.2：getParent():获得调用该方法的加载器的父加载器。
    注意: *父加载器并不是继承关系，是在当前加载器内有一个ClassLoader类型的变量，叫parent,指向父加载器。
          *也不是加载当前加载器的加载器（加载器本身也是一个类，需要被加载）,
          ext/app加载器都是被启动类加载器加载的，调用getClassLoader返回null.
       
##7.Launcher 
     bootstrap/ext/app 这些加载器都是Launcher的静态内部类，在Launcher内定义了各自的访问范围。 

##8.自定义类加载器
    8.1 调用加载器的loadClass()方法，会把二进制文件加载到内存中，返回Class对象。
    8.2 什么时候需要使用自定义加载器：一般是框架内部，比如spring框架的动态代理，要生成一个新的对象时会使用
        自定义的加载器。还有热部署场景的应用，源码修改了，怎么热部署最新的代码，也可以使用自定义加载器加载。
    8.3 loadClass()执行过程：先在缓存中查找该类是否已被加载，若没有加载过，尝试调用父加载器去加载，
        也是先查询父加载器是否加载，若没有，再调用父加载器的父加载器，类似递归。若最后都没有返回Class对象，
        只能由父加载器调用findCLass()自己加载，在指定的范围内查找，若没有找到，返回null，子加载器调用自己的
        findClass()加载，一直往下传递，直到加载完成。
    8.4 自定义加载器实现：
        1.继承ClassLoader
        2.实现findClass()方法（模板方法设计模式）
        3.使用defineClass()方法将二进制文件转换为Class对象
        
##9.懒加载
    1.jvm是采用懒加载的机制，需要用到某个类的时候，才去加载。
    2.但jvm严格规定了什么时候去初始化
        。。。
##10.java执行的时候默认是混合模式，解释执行+编译执行，可以指定具体的模式去执行。
    -Xmixed:默认混合模式
    -Xint:纯解释模式，启动快，执行稍慢。
    -Xcomp:纯编译模式，启动慢，执行快（在代码量多的情况下）
    